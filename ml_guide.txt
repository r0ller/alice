-make parser_generator test_tools ml_tools
-mkdir build/model1
-You cannot really go on until you identify sentences for your use case like:

list contacts with peter
call peter
call one two three
call the first/second/third/fourth/.../last
call the first/second/third/fourth/.../last one

-create a morphological analyzer for the words:

list, contacts, call, one
one, two, three, ...
first, second, third, ...

Let's take the examples from foma and make it minimal.

The phonological rules are as follows:

### english.foma ###

# Vowels
define V [ a | e | i | o | u ];
# Consonants
define C [ b | c | d | f | g | h | j | k | l | m | n | p | q | r | s | t | v | w | x | y | z ];

# E insertion e added after -s, -z, -x, -ch, -sh before s (watch/watches)
define EInsertion [..] -> e || s | z | x | c h | s h _ "^" s ;

# Y replacement: -y changes to -ie before -s, -i before -ed (try/tries) 
define YReplacement y -> i e || _ "^" s ; 

define YthReplacement y -> i e || _ "^" t h ;

# Cleanup: remove morpheme boundaries
define Cleanup "^" -> 0;

read lexc numbers.lexc
define	LexiconNum

define	GrammarNum LexiconNum .o.
		YthReplacement        .o.
		Cleanup;

read lexc engnoun.lexc
define LexiconN

define GrammarN LexiconN         .o. 
               EInsertion        .o. 
               YReplacement      .o. 
               Cleanup;

read lexc english.lexc
define Lexicon

define Grammar Lexicon           .o. 
               Cleanup;

regex GrammarN | GrammarNum | Grammar;

Let's see the lexicons included:

The lexicon for numbers was created to have a common denominator when it comes to interpreting numbers.
At least, I chose to do it in a way because you may either need to interpret numbers in different forms like
roman, arabic and of course written. So I usually convert roman and arabic numbers in texts to their written
english forms.
Notes:
1) This implementation covers only numbers from 0-99.
2) I didn't implement the usage of hyphens in compound numbers between 21-99.

!!!numbers.lexc!!!

Multichar_Symbols [stem] +Num
+Npref1n+ +Npref2n+ +Npref3n+ +Npref4n+
+Npref5n+ +Npref6n+ +Npref7n+ +Npref8n+
+Npref9n+

LEXICON Root

NumPref;

LEXICON Num
zero	NumSuffix;
one		NumSuffix;
two		NumSuffix;
three	NumSuffix;
four	NumSuffix;
five	NumSuffix;
six		NumSuffix;
seven	NumSuffix;
eight	NumSuffix;
nine	NumSuffix;
NumSuffix;

LEXICON NumT
one		NumSuffix;
two		NumSuffix;
three	NumSuffix;
four	NumSuffix;
five	NumSuffix;
six		NumSuffix;
seven	NumSuffix;
eight	NumSuffix;
nine	NumSuffix;
first	NumSuffix;
second	NumSuffix;
third	NumSuffix;
fifth	NumSuffix;
eighth	NumSuffix;
ninth	NumSuffix;

LEXICON Num1
ten 		Num1Suffix;
one:eleven	Num1Suffix;
two:twelve	Num1Suffix;
three:thirteen	Num1Suffix;
four:fourteen	Num1Suffix;
five:fifteen	Num1Suffix;
six:sixteen		Num1Suffix;
seven:seventeen	Num1Suffix;
eight:eighteen	Num1Suffix;
nine:nineteen	Num1Suffix;
Num1Suffix;

LEXICON Num2
twenty 		Num1Suffix;

LEXICON Num3
thirty 		Num1Suffix;

LEXICON Num4
fourty 		Num1Suffix;

LEXICON Num5
fifty 		Num1Suffix;

LEXICON Num6
sixty 		Num1Suffix;

LEXICON Num7
seventy 	Num1Suffix;

LEXICON Num8
eighty 		Num1Suffix;

LEXICON Num9
ninety 		Num1Suffix;

LEXICON NumPref
+Npref2n+:twenty NumT;
+Npref3n+:thirty NumT;
+Npref4n+:fourty NumT;
+Npref5n+:fifty NumT;
+Npref6n+:sixty NumT;
+Npref7n+:seventy NumT;
+Npref8n+:eighty NumT;
+Npref9n+:ninety NumT;
Num;
+Npref1n+:0 Num1;
+Npref2n+:0 Num2;
+Npref3n+:0 Num3;
+Npref4n+:0 Num4;
+Npref5n+:0 Num5;
+Npref6n+:0 Num6;
+Npref7n+:0 Num7;
+Npref8n+:0 Num8;
+Npref9n+:0 Num9;

Lexicon NumSuffix
one[stem]+Num+Ord:first #;
two[stem]+Num+Ord:second #;
three[stem]+Num+Ord:third #;
five[stem]+Num+Ord:fifth #;
eight[stem]+Num+Ord:eighth #;
nine[stem]+Num+Ord:ninth #;
[stem]+Num:th Ord;
[stem]+Num:0 Nom;

Lexicon Num1Suffix
two[stem]+Num+Ord:twelfth #;
[stem]+Num:^th Ord;
[stem]+Num:0 Nom;

Lexicon Nom
+Nom:0 #;

Lexicon Ord
+Ord:0 #;

!!!engnoun.lexc!!!

Multichar_Symbols [stem] +N +Sg +Pl +CON

LEXICON Root

Noun ;

LEXICON Noun

contact Ninf;
name Ninf;
first Ninf;
last Ninf;
one Ninf;

LEXICON Constant
[stem]+CON:0	#;

LEXICON Ninf

[stem]+N+Sg:0   #;
[stem]+N+Pl:^s  #;

!!!english.lexc!!!

Multichar_Symbols [stem] +V +Sg +Pl +PREP +DET

LEXICON Root

Verb ;
Preposition ;
Determiner ;

LEXICON Verb

call Vinf;
list Vinf;

LEXICON Vinf

[stem]+V:0 #;

LEXICON Preposition

with Pinf;

LEXICON Pinf

[stem]+PREP:0 #;

LEXICON Determiner

the[stem]+DET:the #;

-create the morphological analyser:
make desktop_fst DESKTOPFOMAPATH=/home/r0ller/hi/alice/build/model1/english.foma DESKTOPLEXCFILES=/home/r0ller/hi/alice/build/model1 DESKTOPFSTNAME=english.fst
cd hi_desktop

-test your fst by checking if the correct analysis is returned for each word e.g.:
echo contacts|flookup english.fst -> contacts        contact[stem]+N+Pl
echo last|flookup english.fst -> last    last[stem]+N+Sg
echo call|flookup english.fst -> call    call[stem]+V
echo first|flookup english.fst -> first   first[stem]+N+Sg | first   one[stem]+Num+Ord

-Prepare a minimal content for modelling in db.
Notes:
1) watch out for foreign key dependencies as in lexicon->functors->functor_defs
2)fst path is relative to db file location

PRAGMA foreign_keys = ON;
BEGIN;

insert into ROOT_TYPE values('H');
insert into ROOT_TYPE values('N');

insert into PRECEDENCES values('L','%left');
insert into PRECEDENCES values('R','%right');
insert into PRECEDENCES values('P','%precedence');
insert into PRECEDENCES values('N','%nonassoc');

insert into LANGUAGES values('ENG', 'English', '1', 'english.fst');

insert into SYMBOLS values('CON', 'ENG', 'Constant');
insert into SYMBOLS values('DET', 'ENG', 'Determiner');
insert into SYMBOLS values('N', 'ENG', 'Noun');
insert into SYMBOLS values('Stem', 'ENG', 'Stem');
insert into SYMBOLS values('Pl', 'ENG', 'Plural');
insert into SYMBOLS values('Sg', 'ENG', 'Singular');
insert into SYMBOLS values('PREP', 'ENG', 'Preposition');
insert into SYMBOLS values('V', 'ENG', 'Verb');
insert into SYMBOLS values('S','ENG', NULL);
insert into SYMBOLS values('Num','ENG',NULL);
insert into SYMBOLS values('Ord','ENG',NULL);
insert into SYMBOLS values('Npref1n','ENG',NULL);
insert into SYMBOLS values('Npref2n','ENG',NULL);
insert into SYMBOLS values('Npref3n','ENG',NULL);
insert into SYMBOLS values('Npref4n','ENG',NULL);
insert into SYMBOLS values('Npref5n','ENG',NULL);
insert into SYMBOLS values('Npref6n','ENG',NULL);
insert into SYMBOLS values('Npref7n','ENG',NULL);
insert into SYMBOLS values('Npref8n','ENG',NULL);
insert into SYMBOLS values('Npref9n','ENG',NULL);

insert into GCAT values('CON', 'Stem', 'ENG', '1',NULL,NULL);
insert into GCAT values('DET', 'Stem', 'ENG', '1',NULL,NULL);
insert into GCAT values('N', 'Stem', 'ENG', '1',NULL,NULL);
insert into GCAT values('N', 'Pl', 'ENG', '1',NULL,NULL);
insert into GCAT values('N', 'Sg', 'ENG', '1',NULL,NULL);
insert into GCAT values('PREP', 'Stem', 'ENG', '1',NULL,NULL);
insert into GCAT values('V', 'Stem', 'ENG', '1',NULL,NULL);
insert into GCAT values('Num', 'Stem', 'ENG', '1',NULL,NULL);
insert into GCAT values('Num', 'Ord', 'ENG', '1',NULL,NULL);
insert into GCAT values('Num', 'Npref1n', 'ENG', '1',NULL,NULL);
insert into GCAT values('Num', 'Npref2n', 'ENG', '1',NULL,NULL);
insert into GCAT values('Num', 'Npref3n', 'ENG', '1',NULL,NULL);
insert into GCAT values('Num', 'Npref4n', 'ENG', '1',NULL,NULL);
insert into GCAT values('Num', 'Npref5n', 'ENG', '1',NULL,NULL);
insert into GCAT values('Num', 'Npref6n', 'ENG', '1',NULL,NULL);
insert into GCAT values('Num', 'Npref7n', 'ENG', '1',NULL,NULL);
insert into GCAT values('Num', 'Npref8n', 'ENG', '1',NULL,NULL);
insert into GCAT values('Num', 'Npref9n', 'ENG', '1',NULL,NULL);

insert into FUNCTOR_DEFS values('CALLENGV_1', 'js', '1', 'callengv_1.js');
insert into FUNCTOR_DEFS values('LISTENGV_1', 'js', '1', 'listengv_1.js');
insert into FUNCTOR_DEFS values('CONTACTENGN_1', 'js', '1', 'contactengn_1.js');
insert into FUNCTOR_DEFS values('FIRSTLASTENGN_1', 'js', '1', 'firstlastengn_1.js');
insert into FUNCTOR_DEFS values('WITHENGPREP_1', 'js', '1', 'withengprep_1.js');
insert into FUNCTOR_DEFS values('Num_1', 'js', '1', 'numeng_1.js');

insert into FUNCTORS values('CALLENGV', '1', 'CALLENGV_1');
insert into FUNCTORS values('LISTENGV', '1', 'LISTENGV_1');
insert into FUNCTORS values('CONTACTENGN', '1', 'CONTACTENGN_1');
insert into FUNCTORS values('FIRSTLASTENGN', '1', 'FIRSTLASTENGN_1');
insert into FUNCTORS values('WITHENGPREP', '1', 'WITHENGPREP_1');
insert into FUNCTORS values('Num', '1', 'Num_1');

insert into LEXICON values('call', 'ENG', 'V', 'CALLENGV');
insert into LEXICON values('list', 'ENG', 'V', 'LISTENGV');
insert into LEXICON values('contact', 'ENG', 'N', 'CONTACTENGN');
insert into LEXICON values('first', 'ENG', 'N', 'FIRSTLASTENGN');
insert into LEXICON values('last', 'ENG', 'N', 'FIRSTLASTENGN');
insert into LEXICON values('one', 'ENG', 'N', NULL);
insert into LEXICON values('with', 'ENG', 'PREP', 'WITHENGPREP');

COMMIT;

-Create the database:
cat ../../hi_db.sql|sqlite3 m1.db
cat m1content.sql|sqlite3 m1.db

-Create your corpus file with the sentences you want to use for training:
list contacts
list contacts with peter
call peter
call the first
call the first one
call the last
call the last one
call the second
call the second one

-Prepare a stemmed corpus for ABL and check its content:
../prep_abl m1.db corpus.txt ENG stemmed_corpus.txt

abl_align -a a -p b -e -i stemmed_corpus.txt -o m1_aligned.txt
abl_cluster -i m1_aligned.txt -o m1_clustered.txt
abl_select -s b -i m1_clustered.txt -o m1_selected.txt
play around with different selection methods like:
abl_select -s f -i m1_clustered.txt -o m1_selected.txt


../proc_abl m1_selected.txt ENG m1.db
../stex m1.db ENG 10d list,call,contacts,with,peter,the,first,last,one,second > m1stex.txt
../remove_stex_output_duplicates.sh m1stex.txt
TODO: fix makefile to copy this script to build directory
../stax m1stex.txt_unique stemmed_corpus.txt
TODO: stax does not generate all combination of possible sentences

There are two structures for "call the first one":
t_ENG_V_Stem t_ENG_DET_Stem t_ENG_Num_Stem t_ENG_Num_Ord t_ENG_N_Stem t_ENG_N_Sg
t_ENG_V_Stem t_ENG_DET_Stem t_ENG_N_Stem t_ENG_N_Sg t_ENG_N_Stem t_ENG_N_Sg

This is because first has two analyses -see example above.
In case of white box ML like this, you have the possibility to check the output of
all the steps. As a result, you don't have to guess why the ML came up with such a grammar.
Now, we know that it's sufficient to remove the sentence "call the first one" from the training corpus
as "call the last one" will be sufficient to get the correct syntactic structure:
t_ENG_V_Stem t_ENG_DET_Stem t_ENG_Num_Stem t_ENG_Num_Ord t_ENG_N_Stem t_ENG_N_Sg

delete the sentence "call the first one" from corpus.txt
rm m1.db
cat ../../hi_db.sql|sqlite3 m1.db
cat m1content.sql|sqlite3 m1.db
rm stemmed_corpus.txt
rm m1_aligned.txt
rm m1_clustered.txt
rm m1_selected.txt
rm m1stex.txt
rm m1stex.txt_tail
rm m1stex.txt_unique
../prep_abl m1.db corpus.txt ENG stemmed_corpus.txt
